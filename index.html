<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Specter</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&display=swap');

  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --accent: #7df9ff;
    --accent-dim: rgba(125, 249, 255, 0.15);
    --text: #e0e0e4;
    --text-dim: #666;
    --border: rgba(255,255,255,0.08);
    --mono: 'DM Mono', monospace;
    --glow-c: #ff3366;
    --glow-m: #aa44ff;
    --glow-s: #33ff88;
  }

  html, body {
    background: transparent !important;
    font-family: var(--mono);
    height: 100%;
    overflow: hidden;
    user-select: none;
  }

  .app {
    display: flex;
    flex-direction: column;
    height: 100vh;
    position: relative;
  }

  /* â”€â”€ Title bar (draggable) â”€â”€ */
  .titlebar {
    -webkit-app-region: drag;
    display: flex;
    align-items: center;
    justify-content: space-between;
    height: 32px;
    padding: 0 10px;
    background: rgba(10,10,12,0.85);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }

  .titlebar-label {
    font-size: 11px;
    font-weight: 300;
    letter-spacing: 0.1em;
    color: var(--text-dim);
    text-transform: uppercase;
  }

  .titlebar-label span { color: var(--accent); }

  .titlebar-controls {
    -webkit-app-region: no-drag;
    display: flex;
    gap: 6px;
    align-items: center;
  }

  .tb-btn {
    width: 14px; height: 14px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.15s;
  }
  .tb-btn:hover { opacity: 1; }
  .tb-pin { background: #5ac8fa; }
  .tb-pin.pinned { background: var(--accent); box-shadow: 0 0 6px var(--accent); }
  .tb-minimize { background: #ffbd2e; }
  .tb-close { background: #ff5f57; }

  /* â”€â”€ Video / Canvas area â”€â”€ */
  .video-container {
    flex: 1;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    overflow: hidden;
  }

  video {
    display: none;
  }

  canvas#glCanvas {
    width: 100%;
    height: 100%;
    object-fit: contain;
    display: block;
  }

  /* â”€â”€ Drop zone â”€â”€ */
  .drop-zone {
    position: absolute;
    inset: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 10px;
    border: 1.5px dashed rgba(255,255,255,0.12);
    border-radius: 8px;
    background: rgba(10,10,12,0.6);
    z-index: 10;
    transition: all 0.2s;
  }

  .drop-zone.drag-over {
    border-color: var(--accent);
    background: rgba(125, 249, 255, 0.06);
  }

  .drop-zone.hidden { display: none; }

  .drop-icon svg {
    width: 28px; height: 28px;
    stroke: var(--text-dim);
    fill: none;
    stroke-width: 1.5;
  }

  .drop-text {
    font-size: 11px;
    color: var(--text-dim);
    letter-spacing: 0.05em;
  }
  .drop-text strong {
    color: var(--accent);
    cursor: pointer;
  }

  /* â”€â”€ Bottom HUD â”€â”€ */
  .hud {
    flex-shrink: 0;
    background: rgba(10,10,12,0.85);
    border-top: 1px solid var(--border);
    padding: 8px 12px;
    display: flex;
    flex-direction: column;
    gap: 7px;
    transition: opacity 0.2s;
  }

  .hud-row {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  /* Control buttons */
  .ctrl-btn {
    background: none; border: none;
    cursor: pointer; padding: 2px;
    display: flex; align-items: center;
    color: var(--text-dim);
    transition: color 0.15s;
    flex-shrink: 0;
  }
  .ctrl-btn:hover { color: var(--text); }
  .ctrl-btn svg { width: 16px; height: 16px; fill: currentColor; }

  /* â”€â”€ Glitch buttons â”€â”€ */
  .glitch-sep {
    width: 1px;
    height: 16px;
    background: var(--border);
    margin: 0 2px;
    flex-shrink: 0;
  }

  .glitch-btn {
    background: none;
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 3px;
    cursor: pointer;
    padding: 2px 6px;
    font-family: var(--mono);
    font-size: 9px;
    font-weight: 500;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: var(--text-dim);
    transition: all 0.15s;
    flex-shrink: 0;
    position: relative;
  }

  .glitch-btn:hover {
    border-color: rgba(255,255,255,0.2);
    color: var(--text);
  }

  .glitch-btn.active-c {
    color: var(--glow-c);
    border-color: var(--glow-c);
    box-shadow: 0 0 8px rgba(255, 51, 102, 0.3);
  }

  .glitch-btn.active-m {
    color: var(--glow-m);
    border-color: var(--glow-m);
    box-shadow: 0 0 8px rgba(170, 68, 255, 0.3);
  }

  .glitch-btn.active-s {
    color: var(--glow-s);
    border-color: var(--glow-s);
    box-shadow: 0 0 8px rgba(51, 255, 136, 0.3);
  }

  .glitch-btn .intensity-dots {
    display: inline-block;
    margin-left: 3px;
    letter-spacing: 1px;
  }

  /* Progress */
  .progress-wrap {
    flex: 1; height: 20px;
    display: flex; align-items: center;
    cursor: pointer;
  }
  .progress-track {
    width: 100%; height: 2px;
    background: rgba(255,255,255,0.08);
    border-radius: 1px;
    overflow: hidden;
  }
  .progress-fill {
    height: 100%;
    background: var(--accent);
    width: 0%;
  }

  .time-display {
    font-size: 10px;
    color: var(--text-dim);
    letter-spacing: 0.04em;
    flex-shrink: 0;
    min-width: 80px;
    text-align: right;
  }

  /* Opacity row */
  .opacity-row {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .opacity-label {
    font-size: 9px;
    color: var(--text-dim);
    letter-spacing: 0.1em;
    text-transform: uppercase;
    flex-shrink: 0;
    width: 55px;
  }

  .step-btn {
    flex: 1;
    height: 22px;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 3px;
    color: var(--text-dim);
    font-family: var(--mono);
    font-size: 10px;
    cursor: pointer;
    transition: all 0.12s;
    position: relative;
    overflow: hidden;
  }

  .step-btn::before {
    content: '';
    position: absolute; inset: 0;
    background: var(--accent);
    opacity: 0;
    transition: opacity 0.12s;
  }

  .step-btn:hover { border-color: var(--accent); }

  .step-btn.active {
    border-color: var(--accent);
    color: #0a0a0b;
    font-weight: 500;
  }
  .step-btn.active::before { opacity: 1; }
  .step-btn i { position: relative; z-index: 1; font-style: normal; }

  /* Auto-hide HUD on hover-away */
  .hud-autohide .hud,
  .hud-autohide .titlebar {
    opacity: 0;
    pointer-events: none;
  }
  .hud-autohide:hover .hud,
  .hud-autohide:hover .titlebar {
    opacity: 1;
    pointer-events: auto;
  }
</style>
</head>
<body>

<div class="app" id="app">
  <div class="titlebar">
    <div class="titlebar-label"><span>ğŸ‘»</span> specter</div>
    <div class="titlebar-controls">
      <button class="tb-btn tb-pin pinned" id="pinBtn" title="Always on top"></button>
      <button class="tb-btn tb-minimize" id="minBtn" title="Minimize"></button>
      <button class="tb-btn tb-close" id="closeBtn" title="Close"></button>
    </div>
  </div>

  <div class="video-container" id="videoContainer">
    <video id="video" preload="metadata" crossorigin="anonymous"></video>
    <canvas id="glCanvas"></canvas>
    <div class="drop-zone" id="dropZone">
      <div class="drop-icon">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
          <polyline points="17 8 12 3 7 8"/>
          <line x1="12" y1="3" x2="12" y2="15"/>
        </svg>
      </div>
      <div class="drop-text">Drop video or <strong id="browseBtn">browse</strong></div>
    </div>
  </div>

  <div class="hud" id="hud">
    <div class="hud-row">
      <button class="ctrl-btn" id="playBtn" title="Play/Pause">
        <svg viewBox="0 0 24 24" id="playIcon"><path d="M5 3l14 9-14 9V3z"/></svg>
      </button>
      <button class="ctrl-btn" id="framePrevBtn" title="Previous frame ( , )">
        <svg viewBox="0 0 24 24"><path d="M19 20L9 12l10-8v16zM5 4h2v16H5V4z"/></svg>
      </button>
      <button class="ctrl-btn" id="frameNextBtn" title="Next frame ( . )">
        <svg viewBox="0 0 24 24"><path d="M5 4l10 8-10 8V4zm12 0h2v16h-2V4z"/></svg>
      </button>
      <div class="progress-wrap" id="progressWrap">
        <div class="progress-track">
          <div class="progress-fill" id="progressFill"></div>
        </div>
      </div>
      <button class="ctrl-btn" id="volBtn" title="Toggle mute (M)">
        <svg viewBox="0 0 24 24" id="volIcon"><path d="M11 5L6 9H2v6h4l5 4V5zm8.07.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>
      </button>
      <button class="ctrl-btn" id="volHalfBtn" title="50% volume">
        <svg viewBox="0 0 24 24" style="width:12px;height:12px;"><text x="1" y="17" font-size="16" fill="currentColor" font-family="monospace">Â½</text></svg>
      </button>
      <div class="glitch-sep"></div>
      <button class="glitch-btn" id="glitchC" title="Chromatic RGB Split (C)">C<span class="intensity-dots"></span></button>
      <button class="glitch-btn" id="glitchM" title="Melt Datamosh (V)">M<span class="intensity-dots"></span></button>
      <button class="glitch-btn" id="glitchS" title="Signal Corruption (B)">S<span class="intensity-dots"></span></button>
      <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
    </div>
    <div class="hud-row opacity-row">
      <div class="opacity-label">opacity</div>
      <div id="opacitySteps" style="display:flex;gap:3px;flex:1;"></div>
    </div>
  </div>
</div>

<input type="file" id="fileInput" accept="video/*" style="display:none">

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     VERTEX SHADER
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script id="vs" type="x-shader/x-vertex">
  attribute vec2 a_position;
  attribute vec2 a_texCoord;
  varying vec2 v_uv;
  void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
    v_uv = a_texCoord;
  }
</script>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     FRAGMENT SHADER â€” all 3 glitch effects in one pass
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script id="fs" type="x-shader/x-fragment">
  precision mediump float;

  varying vec2 v_uv;
  uniform sampler2D u_video;
  uniform vec2 u_resolution;
  uniform float u_time;

  // Effect intensities (0.0 = off, 0.33 = low, 0.66 = med, 1.0 = high)
  uniform float u_chromatic;
  uniform float u_melt;
  uniform float u_signal;

  // â”€â”€ Noise helpers â”€â”€
  float hash(float n) {
    return fract(sin(n) * 43758.5453123);
  }

  float hash2(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
  }

  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    float a = hash2(i);
    float b = hash2(i + vec2(1.0, 0.0));
    float c = hash2(i + vec2(0.0, 1.0));
    float d = hash2(i + vec2(1.0, 1.0));
    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
  }

  // Block noise for datamosh feel
  float blockNoise(vec2 uv, float blockSize) {
    vec2 block = floor(uv * blockSize) / blockSize;
    return hash2(block + floor(u_time * 2.0));
  }

  void main() {
    vec2 uv = v_uv;
    vec4 color;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EFFECT 1: MELT (Datamosh displacement)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (u_melt > 0.0) {
      float intensity = u_melt;

      // Create blocky displacement zones
      float blockSize = mix(8.0, 4.0, intensity);
      vec2 block = floor(uv * blockSize);
      float trigger = hash2(block + floor(u_time * 1.5));

      // Only displace some blocks (more blocks at higher intensity)
      float threshold = mix(0.8, 0.4, intensity);

      if (trigger > threshold) {
        // Displacement direction from noise
        float angle = hash2(block * 7.77 + floor(u_time * 2.0)) * 6.2831;
        float dist = hash2(block * 3.33 + floor(u_time * 1.8)) * intensity * 0.12;

        uv += vec2(cos(angle), sin(angle)) * dist;

        // Smear: blend with a time-offset sample for ghosting
        float smear = noise(block * 5.0 + u_time) * intensity * 0.06;
        uv.y += smear;
      }

      // Macro displacement waves (the smooth melting feel)
      float wave = noise(vec2(uv.y * 3.0, u_time * 0.7)) * 2.0 - 1.0;
      uv.x += wave * intensity * 0.025;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EFFECT 3: SIGNAL (Scanline corruption)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (u_signal > 0.0) {
      float intensity = u_signal;

      // Scanline groups with random horizontal shift
      float scanH = mix(80.0, 30.0, intensity);
      float scanGroup = floor(uv.y * scanH);
      float groupSeed = hash(scanGroup + floor(u_time * 4.0) * 99.0);

      // Only shift some scanline groups
      float shiftThreshold = mix(0.85, 0.55, intensity);
      if (groupSeed > shiftThreshold) {
        float shiftAmount = (hash(scanGroup * 17.0 + floor(u_time * 6.0)) * 2.0 - 1.0);
        uv.x += shiftAmount * intensity * 0.15;
      }

      // Occasional full-width tears
      float tearSeed = hash(floor(u_time * 3.0) + 0.5);
      if (tearSeed > 0.7) {
        float tearY = hash(floor(u_time * 5.0)) ;
        float tearWidth = 0.005 + intensity * 0.02;
        if (abs(uv.y - tearY) < tearWidth) {
          uv.x += (hash(uv.y * 500.0 + u_time) * 2.0 - 1.0) * intensity * 0.3;
        }
      }

      // Subtle vertical jitter
      uv.y += (hash(floor(u_time * 8.0)) * 2.0 - 1.0) * intensity * 0.003;
    }

    // Clamp UV after displacement
    uv = clamp(uv, 0.0, 1.0);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EFFECT 2: CHROMATIC (RGB Channel Split)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (u_chromatic > 0.0) {
      float intensity = u_chromatic;

      // Base offset that shifts over time
      float angle = u_time * 0.5;
      vec2 dir = vec2(cos(angle), sin(angle));
      float offset = intensity * 0.015;

      // Add some wobble for organic feel
      float wobble = sin(uv.y * 20.0 + u_time * 3.0) * intensity * 0.003;

      vec2 rOff = dir * (offset + wobble);
      vec2 bOff = -dir * (offset + wobble);

      // Green stays centered, R and B split apart
      float r = texture2D(u_video, clamp(uv + rOff, 0.0, 1.0)).r;
      float g = texture2D(u_video, uv).g;
      float b = texture2D(u_video, clamp(uv + bOff, 0.0, 1.0)).b;

      color = vec4(r, g, b, 1.0);
    } else {
      color = texture2D(u_video, uv);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SIGNAL post-pass: color banding + noise
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (u_signal > 0.0) {
      float intensity = u_signal;

      // Scanline darkening
      float scanline = sin(v_uv.y * u_resolution.y * 1.5) * 0.5 + 0.5;
      color.rgb *= 1.0 - scanline * intensity * 0.15;

      // Color channel noise (the green/purple you love)
      float cn = hash2(v_uv * u_resolution + floor(u_time * 10.0)) * 2.0 - 1.0;
      color.r += cn * intensity * 0.08;
      color.g -= cn * intensity * 0.06;
      color.b += cn * intensity * 0.1;

      // Random color band flashes
      float bandSeed = hash(floor(v_uv.y * 20.0) + floor(u_time * 5.0));
      if (bandSeed > mix(0.95, 0.8, intensity)) {
        color.rgb = mix(color.rgb, vec3(cn * 0.5 + 0.5, 1.0 - color.g, color.b * 0.5), intensity * 0.6);
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MELT post-pass: color bleed between channels
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (u_melt > 0.0) {
      float intensity = u_melt;

      // Block-based color shift (green/magenta bleeding)
      float blockSize = mix(12.0, 6.0, intensity);
      float bn = blockNoise(v_uv, blockSize);

      if (bn > mix(0.85, 0.6, intensity)) {
        // Shift hue by swapping/blending channels
        float shift = hash2(floor(v_uv * blockSize) + floor(u_time * 2.0));
        if (shift > 0.5) {
          color.rgb = mix(color.rgb, color.grb, intensity * 0.5);  // green-magenta shift
        } else {
          color.rgb = mix(color.rgb, color.brg, intensity * 0.4);  // cyan-purple shift
        }
      }

      // Smooth noise overlay (the "smooth noise" you described)
      float smoothN = noise(v_uv * 8.0 + u_time * 0.5);
      color.g += smoothN * intensity * 0.05;
      color.b -= smoothN * intensity * 0.03;
    }

    // Ensure valid color range
    color.rgb = clamp(color.rgb, 0.0, 1.0);
    color.a = 1.0;

    gl_FragColor = color;
  }
</script>

<script>
  const { ipcRenderer } = require('electron');

  // â”€â”€ DOM refs â”€â”€
  const video = document.getElementById('video');
  const canvas = document.getElementById('glCanvas');
  const dropZone = document.getElementById('dropZone');
  const playBtn = document.getElementById('playBtn');
  const playIcon = document.getElementById('playIcon');
  const progressFill = document.getElementById('progressFill');
  const progressWrap = document.getElementById('progressWrap');
  const timeDisplay = document.getElementById('timeDisplay');
  const opacitySteps = document.getElementById('opacitySteps');
  const fileInput = document.getElementById('fileInput');
  const browseBtn = document.getElementById('browseBtn');
  const pinBtn = document.getElementById('pinBtn');
  const minBtn = document.getElementById('minBtn');
  const closeBtn = document.getElementById('closeBtn');
  const appEl = document.getElementById('app');
  const videoContainer = document.getElementById('videoContainer');
  const framePrevBtn = document.getElementById('framePrevBtn');
  const frameNextBtn = document.getElementById('frameNextBtn');
  const volBtn = document.getElementById('volBtn');
  const volHalfBtn = document.getElementById('volHalfBtn');
  const volIcon = document.getElementById('volIcon');
  const glitchCBtn = document.getElementById('glitchC');
  const glitchMBtn = document.getElementById('glitchM');
  const glitchSBtn = document.getElementById('glitchS');

  let currentLevel = 9;
  let pinned = true;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WEBGL SETUP
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const gl = canvas.getContext('webgl', {
    premultipliedAlpha: false,
    alpha: true,
    preserveDrawingBuffer: false,
    antialias: false,
  });

  function compileShader(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      console.error('Shader error:', gl.getShaderInfoLog(s));
      return null;
    }
    return s;
  }

  const vs = compileShader(gl.VERTEX_SHADER, document.getElementById('vs').textContent);
  const fs = compileShader(gl.FRAGMENT_SHADER, document.getElementById('fs').textContent);

  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
  }

  gl.useProgram(program);

  // Geometry: full-screen quad
  const posBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,  1, -1,  -1, 1,
    -1,  1,  1, -1,   1, 1,
  ]), gl.STATIC_DRAW);

  const posLoc = gl.getAttribLocation(program, 'a_position');
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

  const tcBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, tcBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    0, 1,  1, 1,  0, 0,
    0, 0,  1, 1,  1, 0,
  ]), gl.STATIC_DRAW);

  const tcLoc = gl.getAttribLocation(program, 'a_texCoord');
  gl.enableVertexAttribArray(tcLoc);
  gl.vertexAttribPointer(tcLoc, 2, gl.FLOAT, false, 0, 0);

  // Video texture
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

  // Uniform locations
  const uVideo = gl.getUniformLocation(program, 'u_video');
  const uResolution = gl.getUniformLocation(program, 'u_resolution');
  const uTime = gl.getUniformLocation(program, 'u_time');
  const uChromatic = gl.getUniformLocation(program, 'u_chromatic');
  const uMelt = gl.getUniformLocation(program, 'u_melt');
  const uSignal = gl.getUniformLocation(program, 'u_signal');

  gl.uniform1i(uVideo, 0);

  // â”€â”€ Glitch state â”€â”€
  // Each effect cycles: 0 (off) â†’ 0.33 (low) â†’ 0.66 (med) â†’ 1.0 (high) â†’ 0 (off)
  const glitchState = { chromatic: 0, melt: 0, signal: 0 };
  const intensityLevels = [0, 0.33, 0.66, 1.0];
  const dotChars = ['', 'Â·', 'Â·Â·', 'Â·Â·Â·'];

  function cycleGlitch(effect, btn, activeClass) {
    const idx = intensityLevels.indexOf(glitchState[effect]);
    const next = (idx + 1) % intensityLevels.length;
    glitchState[effect] = intensityLevels[next];

    btn.classList.toggle(activeClass, next > 0);
    btn.querySelector('.intensity-dots').textContent = dotChars[next];
  }

  glitchCBtn.addEventListener('click', () => cycleGlitch('chromatic', glitchCBtn, 'active-c'));
  glitchMBtn.addEventListener('click', () => cycleGlitch('melt', glitchMBtn, 'active-m'));
  glitchSBtn.addEventListener('click', () => cycleGlitch('signal', glitchSBtn, 'active-s'));

  // â”€â”€ Render loop â”€â”€
  let videoReady = false;
  let animId = null;
  const startTime = performance.now();

  function resizeCanvas() {
    const w = videoContainer.clientWidth;
    const h = videoContainer.clientHeight;
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
      gl.viewport(0, 0, w, h);
    }
  }

  function render() {
    animId = requestAnimationFrame(render);

    if (!videoReady) return;

    resizeCanvas();

    const t = (performance.now() - startTime) / 1000.0;

    // Upload video frame to texture
    try {
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    } catch (e) {
      return; // Video not ready yet
    }

    // Set uniforms
    gl.uniform2f(uResolution, canvas.width, canvas.height);
    gl.uniform1f(uTime, t);
    gl.uniform1f(uChromatic, glitchState.chromatic);
    gl.uniform1f(uMelt, glitchState.melt);
    gl.uniform1f(uSignal, glitchState.signal);

    // Draw
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }

  // Start render loop
  render();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // OPACITY
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const opacityMap = {
    0: 0.09, 1: 0.21, 2: 0.33, 3: 0.55, 4: 0.71,
    5: 0.83, 6: 0.90, 7: 0.94, 8: 0.97, 9: 0.99
  };

  for (let i = 0; i <= 9; i++) {
    const btn = document.createElement('button');
    btn.className = 'step-btn' + (i === 9 ? ' active' : '');
    btn.innerHTML = `<i>${i}</i>`;
    btn.dataset.level = i;
    btn.addEventListener('click', () => setOpacity(i));
    opacitySteps.appendChild(btn);
  }

  function setOpacity(level) {
    currentLevel = level;
    canvas.style.opacity = opacityMap[level];

    document.querySelectorAll('.step-btn').forEach(b => {
      b.classList.toggle('active', parseInt(b.dataset.level) === level);
    });

    if (level <= 7 && video.src) {
      appEl.classList.add('hud-autohide');
    } else {
      appEl.classList.remove('hud-autohide');
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FILE LOADING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let currentObjectUrl = null;

  function loadFile(file) {
    if (currentObjectUrl) URL.revokeObjectURL(currentObjectUrl);
    currentObjectUrl = URL.createObjectURL(file);
    video.src = currentObjectUrl;
    video.load();
    dropZone.classList.add('hidden');
  }

  browseBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    fileInput.click();
  });

  fileInput.addEventListener('change', (e) => {
    if (e.target.files[0]) loadFile(e.target.files[0]);
  });

  // Video ready â†’ enable rendering
  video.addEventListener('loadeddata', () => {
    videoReady = true;
  });

  // Drag & drop
  document.addEventListener('dragover', (e) => e.preventDefault());
  document.addEventListener('drop', (e) => e.preventDefault());

  ['dragenter', 'dragover'].forEach(evt => {
    dropZone.addEventListener(evt, (e) => {
      e.preventDefault();
      dropZone.classList.add('drag-over');
    });
  });
  ['dragleave', 'drop'].forEach(evt => {
    dropZone.addEventListener(evt, () => dropZone.classList.remove('drag-over'));
  });

  dropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file && file.type.startsWith('video/')) loadFile(file);
  });

  videoContainer.addEventListener('drop', (e) => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file && file.type.startsWith('video/')) loadFile(file);
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PLAYBACK
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const pausePath = 'M6 4h4v16H6zm8 0h4v16h-4z';
  const playPath = 'M5 3l14 9-14 9V3z';

  function togglePlay() {
    if (!video.src) return;
    video.paused ? video.play() : video.pause();
  }

  video.addEventListener('play', () => playIcon.innerHTML = `<path d="${pausePath}"/>`);
  video.addEventListener('pause', () => playIcon.innerHTML = `<path d="${playPath}"/>`);

  playBtn.addEventListener('click', togglePlay);
  canvas.addEventListener('click', togglePlay);

  function fmt(s) {
    if (isNaN(s)) return '0:00';
    return `${Math.floor(s/60)}:${Math.floor(s%60).toString().padStart(2,'0')}`;
  }

  let lastTimeUpdate = 0;
  video.addEventListener('timeupdate', () => {
    if (!video.duration) return;
    const now = performance.now();
    if (now - lastTimeUpdate < 100) return;
    lastTimeUpdate = now;
    progressFill.style.width = (video.currentTime / video.duration * 100) + '%';
    timeDisplay.textContent = `${fmt(video.currentTime)} / ${fmt(video.duration)}`;
  });

  progressWrap.addEventListener('click', (e) => {
    if (!video.duration) return;
    const rect = progressWrap.getBoundingClientRect();
    video.currentTime = ((e.clientX - rect.left) / rect.width) * video.duration;
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FRAME STEPPING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function getFrameDuration() { return 1 / 30; }

  let seeking = false;

  function stepFrame(direction) {
    if (!video.src || !video.duration || seeking) return;
    video.pause();
    seeking = true;
    const delta = getFrameDuration() * direction;
    video.currentTime = Math.max(0, Math.min(video.duration, video.currentTime + delta));
  }

  video.addEventListener('seeked', () => { seeking = false; });

  framePrevBtn.addEventListener('click', () => stepFrame(-1));
  frameNextBtn.addEventListener('click', () => stepFrame(1));

  // Scroll wheel = frame step (throttled)
  let wheelLocked = false;
  videoContainer.addEventListener('wheel', (e) => {
    if (!video.src || wheelLocked) return;
    e.preventDefault();
    wheelLocked = true;
    const direction = e.deltaY > 0 ? 1 : -1;
    stepFrame(direction);
    setTimeout(() => { wheelLocked = false; }, 50);
  }, { passive: false });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // VOLUME
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const volOnPath = 'M11 5L6 9H2v6h4l5 4V5zm8.07.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07';
  const volMutePath = 'M11 5L6 9H2v6h4l5 4V5zm12.41 3.59L21 7l-1.41-1.41L17 8.17l-2.59-2.58L13 7l2.59 2.59L13 12.17l1.41 1.41L17 11l2.59 2.59L21 12.17l-2.59-2.58z';
  const volLowPath = 'M11 5L6 9H2v6h4l5 4V5zm4.54 3.46a5 5 0 0 1 0 7.07';

  function updateVolIcon() {
    if (video.muted || video.volume === 0) {
      volIcon.innerHTML = `<path d="${volMutePath}"/>`;
    } else if (video.volume <= 0.5) {
      volIcon.innerHTML = `<path d="${volLowPath}"/>`;
    } else {
      volIcon.innerHTML = `<path d="${volOnPath}"/>`;
    }
  }

  volBtn.addEventListener('click', () => { video.muted = !video.muted; updateVolIcon(); });
  volHalfBtn.addEventListener('click', () => { video.muted = false; video.volume = 0.5; updateVolIcon(); });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TITLEBAR CONTROLS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  pinBtn.addEventListener('click', () => {
    pinned = !pinned;
    pinBtn.classList.toggle('pinned', pinned);
    ipcRenderer.send('set-always-on-top', pinned);
  });

  minBtn.addEventListener('click', () => ipcRenderer.send('minimize-window'));
  closeBtn.addEventListener('click', () => window.close());

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FINE OPACITY
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function fineOpacity(delta) {
    const current = parseFloat(canvas.style.opacity);
    const val = isNaN(current) ? opacityMap[currentLevel] : current;
    canvas.style.opacity = Math.max(0, Math.min(1, +(val + delta).toFixed(2)));
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // KEYBOARD
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  document.addEventListener('keydown', (e) => {
    if (e.key === ' ') { e.preventDefault(); togglePlay(); }
    else if (e.key >= '0' && e.key <= '9' && !e.shiftKey) { setOpacity(parseInt(e.key)); }
    // Shift + arrows
    else if (e.shiftKey && e.key === 'ArrowLeft') { e.preventDefault(); video.currentTime = Math.max(0, video.currentTime - 1); }
    else if (e.shiftKey && e.key === 'ArrowRight') { e.preventDefault(); video.currentTime = Math.min(video.duration || 0, video.currentTime + 1); }
    else if (e.shiftKey && e.key === 'ArrowUp') { e.preventDefault(); if (currentLevel < 9) setOpacity(currentLevel + 1); }
    else if (e.shiftKey && e.key === 'ArrowDown') { e.preventDefault(); if (currentLevel > 0) setOpacity(currentLevel - 1); }
    // Plain arrows
    else if (e.key === 'ArrowLeft') { e.preventDefault(); stepFrame(-1); }
    else if (e.key === 'ArrowRight') { e.preventDefault(); stepFrame(1); }
    else if (e.key === 'ArrowUp') { e.preventDefault(); fineOpacity(0.01); }
    else if (e.key === 'ArrowDown') { e.preventDefault(); fineOpacity(-0.01); }
    // Frame step keys
    else if (e.key === ',') { e.preventDefault(); stepFrame(-1); }
    else if (e.key === '.') { e.preventDefault(); stepFrame(1); }
    // Glitch toggles
    else if (e.key === 'c') { cycleGlitch('chromatic', glitchCBtn, 'active-c'); }
    else if (e.key === 'v') { cycleGlitch('melt', glitchMBtn, 'active-m'); }
    else if (e.key === 'b') { cycleGlitch('signal', glitchSBtn, 'active-s'); }
    // Other
    else if (e.key === 'm') { video.muted = !video.muted; updateVolIcon(); }
    else if (e.key === 'h') { appEl.classList.toggle('hud-autohide'); }
    else if (e.key === 'Escape') { window.close(); }
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ERROR RECOVERY & CLEANUP
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  video.addEventListener('error', (e) => {
    console.error('Video error:', video.error?.message || 'unknown');
    const pos = video.currentTime;
    const src = video.src;
    if (src) {
      video.load();
      video.addEventListener('loadedmetadata', () => {
        video.currentTime = pos;
      }, { once: true });
    }
  });

  window.addEventListener('beforeunload', () => {
    if (animId) cancelAnimationFrame(animId);
    if (currentObjectUrl) URL.revokeObjectURL(currentObjectUrl);
    video.pause();
    video.removeAttribute('src');
    video.load();
  });

  // â”€â”€ Loop by default â”€â”€
  video.loop = true;
</script>
</body>
</html>